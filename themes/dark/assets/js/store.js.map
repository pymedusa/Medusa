{"version":3,"names":[],"mappings":"","sources":["js/store.js"],"sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/* globals Vue */\nconst Puex = window.puex.default;\nconst VueNativeSock = window.VueNativeSock.default;\nconst displayNotification = window.displayNotification;\n\nVue.use(Puex);\n\n// These are used for mutation names\n// There are no naming conventions so try and match\n// similarly to what we already use when adding new ones.\nconst mutationTypes = {\n    LOGIN_PENDING: '🔒 Logging in',\n    LOGIN_SUCCESS: '🔒 ✅ Login Successful',\n    LOGIN_FAILED: '🔒 ❌ Login Failed',\n    LOGOUT: '🔒 Logout',\n    REFRESH_TOKEN: '🔒 Refresh Token',\n    REMOVE_AUTH_ERROR: '🔒 Remove Auth Error',\n    SOCKET_ONOPEN: 'SOCKET_ONOPEN',\n    SOCKET_ONCLOSE: 'SOCKET_ONCLOSE',\n    SOCKET_ONERROR: 'SOCKET_ONERROR',\n    SOCKET_ONMESSAGE: 'SOCKET_ONMESSAGE',\n    SOCKET_RECONNECT: 'SOCKET_RECONNECT',\n    SOCKET_RECONNECT_ERROR: 'SOCKET_RECONNECT_ERROR',\n    NOTIFICATIONS_ENABLED: '🔔 Notifications Enabled',\n    NOTIFICATIONS_DISABLED: '🔔 Notifications Disabled',\n    ADD_CONFIG: '⚙️ Config added to store',\n    ADD_SHOW: '📺 Show added to store'\n};\n\n// This will be moved up later on\n// once we move mutationTypes to a seperate file.\nconst {\n    LOGIN_PENDING,\n    LOGIN_SUCCESS,\n    LOGIN_FAILED,\n    LOGOUT,\n    REFRESH_TOKEN,\n    REMOVE_AUTH_ERROR,\n    SOCKET_ONOPEN,\n    SOCKET_ONCLOSE,\n    SOCKET_ONERROR,\n    SOCKET_ONMESSAGE,\n    SOCKET_RECONNECT,\n    SOCKET_RECONNECT_ERROR,\n    NOTIFICATIONS_ENABLED,\n    NOTIFICATIONS_DISABLED,\n    ADD_CONFIG,\n    ADD_SHOW\n} = mutationTypes;\n\nconst store = new Puex({\n    state: {\n        auth: {\n            isAuthenticated: false,\n            user: {},\n            tokens: {\n                access: null,\n                refresh: null\n            },\n            error: null\n        },\n        // Websocket\n        socket: {\n            isConnected: false,\n            // Current message\n            message: {},\n            // Delivered messages for this session\n            messages: [],\n            reconnectError: false\n        },\n        notifications: {\n            enabled: true\n        },\n        qualities: {},\n        statuses: {},\n        // Main config\n        config: {\n            wikiUrl: null,\n            localUser: null,\n            posterSortdir: null,\n            locale: null,\n            themeName: null,\n            selectedRootIndex: null,\n            webRoot: null,\n            namingForceFolders: null,\n            cacheDir: null,\n            databaseVersion: {\n                major: null,\n                minor: null\n            },\n            programDir: null,\n            animeSplitHomeInTabs: null,\n            torrents: {\n                authType: null,\n                dir: null,\n                enabled: null,\n                highBandwidth: null,\n                host: null,\n                label: null,\n                labelAnime: null,\n                method: null,\n                path: null,\n                paused: null,\n                rpcurl: null,\n                seedLocation: null,\n                seedTime: null,\n                username: null,\n                verifySSL: null\n            },\n            layout: {\n                show: {\n                    specials: null,\n                    showListOrder: [],\n                    allSeasons: null\n                },\n                home: null,\n                history: null,\n                schedule: null\n            },\n            dbPath: null,\n            nzb: {\n                enabled: null,\n                method: null,\n                nzbget: {\n                    category: null,\n                    categoryAnime: null,\n                    categoryAnimeBacklog: null,\n                    categoryBacklog: null,\n                    host: null,\n                    priority: null,\n                    useHttps: null,\n                    username: null\n                },\n                sabnzbd: {\n                    category: null,\n                    forced: null,\n                    categoryAnime: null,\n                    categoryBacklog: null,\n                    categoryAnimeBacklog: null,\n                    host: null,\n                    username: null\n                }\n            },\n            configFile: null,\n            fanartBackground: null,\n            trimZero: null,\n            animeSplitHome: null,\n            branch: null,\n            commitHash: null,\n            indexers: {\n                config: {\n                    main: {\n                        externalMappings: {},\n                        statusMap: {},\n                        traktIndexers: {},\n                        validLanguages: [],\n                        langabbvToId: {}\n                    },\n                    indexers: {\n                        tvdb: {\n                            apiParams: {\n                                useZip: null,\n                                language: null\n                            },\n                            baseUrl: null,\n                            enabled: null,\n                            icon: null,\n                            id: null,\n                            identifier: null,\n                            mappedTo: null,\n                            name: null,\n                            scene_loc: null, // eslint-disable-line camelcase\n                            showUrl: null,\n                            xemOrigin: null\n                        },\n                        tmdb: {\n                            apiParams: {\n                                useZip: null,\n                                language: null\n                            },\n                            baseUrl: null,\n                            enabled: null,\n                            icon: null,\n                            id: null,\n                            identifier: null,\n                            mappedTo: null,\n                            name: null,\n                            scene_loc: null, // eslint-disable-line camelcase\n                            showUrl: null,\n                            xemOrigin: null\n                        },\n                        tvmaze: {\n                            apiParams: {\n                                useZip: null,\n                                language: null\n                            },\n                            baseUrl: null,\n                            enabled: null,\n                            icon: null,\n                            id: null,\n                            identifier: null,\n                            mappedTo: null,\n                            name: null,\n                            scene_loc: null, // eslint-disable-line camelcase\n                            showUrl: null,\n                            xemOrigin: null\n                        }\n                    }\n                }\n            },\n            sourceUrl: null,\n            rootDirs: [],\n            fanartBackgroundOpacity: null,\n            appArgs: [],\n            emby: {\n                enabled: null\n            },\n            comingEpsDisplayPaused: null,\n            sortArticle: null,\n            timePreset: null,\n            plex: {\n                client: {\n                    host: [],\n                    username: null,\n                    enabled: null\n                },\n                server: {\n                    updateLibrary: null,\n                    host: [],\n                    enabled: null,\n                    notify: {\n                        download: null,\n                        subtitleDownload: null,\n                        snatch: null\n                    }\n                }\n            },\n            subtitles: {\n                enabled: null\n            },\n            fuzzyDating: null,\n            backlogOverview: {\n                status: null,\n                period: null\n            },\n            posterSortby: null,\n            kodi: {\n                enabled: null,\n                alwaysOn: null,\n                libraryCleanPending: null,\n                cleanLibrary: null,\n                host: [],\n                notify: {\n                    snatch: null,\n                    download: null,\n                    subtitleDownload: null\n                },\n                update: {\n                    library: null,\n                    full: null,\n                    onlyFirst: null\n                }\n            },\n            news: {\n                lastRead: null,\n                latest: null,\n                unread: null\n            },\n            sslVersion: null,\n            pythonVersion: null,\n            comingEpsSort: null,\n            githubUrl: null,\n            datePreset: null,\n            subtitlesMulti: null,\n            os: null,\n            anonRedirect: null,\n            logDir: null\n        },\n        // Loaded show list\n        // New shows can be added via\n        // $store.dispatch('getShow', { indexer, id });\n        shows: [],\n        // We use this so we can fallback to a\n        // default object that resides in the shows array\n        defaults: {\n            show: {\n                id: {\n                    tvdb: null,\n                    slug: null\n                },\n                rating: {\n                    imdb: {\n                        rating: null,\n                        votes: null\n                    }\n                },\n                country_codes: [], // eslint-disable-line camelcase\n                network: null,\n                airs: null,\n                config: {\n                    qualities: null,\n                    defaultEpisodeStatus: null,\n                    dvdOrder: null,\n                    seasonFolders: null,\n                    scene: null,\n                    sports: null,\n                    paused: null,\n                    location: null,\n                    airByDate: null,\n                    release: null,\n                    aliases: null,\n                    subtitlesEnabled: null,\n                    anime: null\n                }\n            }\n        }\n    },\n    // The only place the state should be updated is here\n    // Please add new mutations in the same order as the mutatinType list\n    mutations: {\n        [LOGIN_PENDING]() {},\n        [LOGIN_SUCCESS](state, user) {\n            state.auth.user = user;\n            state.auth.isAuthenticated = true;\n            state.auth.error = null;\n        },\n        [LOGIN_FAILED](state, { error }) {\n            state.auth.user = {};\n            state.auth.isAuthenticated = false;\n            state.auth.error = error;\n        },\n        [LOGOUT](state) {\n            state.auth.user = {};\n            state.auth.isAuthenticated = false;\n            state.auth.error = null;\n        },\n        [REFRESH_TOKEN]() {},\n        [REMOVE_AUTH_ERROR]() {},\n        [SOCKET_ONOPEN](state) {\n            state.socket.isConnected = true;\n        },\n        [SOCKET_ONCLOSE](state) {\n            state.socket.isConnected = false;\n        },\n        [SOCKET_ONERROR](state, event) {\n            console.error(state, event);\n        },\n        // Default handler called for all websocket methods\n        [SOCKET_ONMESSAGE](state, message) {\n            const { data, event } = message;\n\n            // Set the current message\n            state.socket.message = message;\n\n            if (event === 'notification') {\n                // Save it so we can look it up later\n                const existingMessage = state.socket.messages.filter(message => message.hash === data.hash);\n                if (existingMessage.length === 1) {\n                    state.socket.messages[state.socket.messages.indexOf(existingMessage)] = message;\n                } else {\n                    state.socket.messages.push(message);\n                }\n            }\n        },\n        // Mutations for websocket reconnect methods\n        [SOCKET_RECONNECT](state, count) {\n            console.info(state, count);\n        },\n        [SOCKET_RECONNECT_ERROR](state) {\n            state.socket.reconnectError = true;\n\n            const title = 'Error connecting to websocket';\n            let error = '';\n            error += 'Please check your network connection. ';\n            error += 'If you are using a reverse proxy, please take a look at our wiki for config examples.';\n\n            displayNotification('notice', title, error);\n        },\n        [NOTIFICATIONS_ENABLED](state) {\n            state.notifications.enabled = true;\n        },\n        [NOTIFICATIONS_DISABLED](state) {\n            state.notifications.enabled = false;\n        },\n        [ADD_CONFIG](state, { section, config }) {\n            if (section === 'main') {\n                state.config = config;\n            }\n            if (['qualities', 'statuses'].includes(section)) {\n                state[section] = config;\n            }\n        },\n        [ADD_SHOW](state, show) {\n            const { shows } = state;\n            const showExists = shows.filter(({ id, indexer }) => id[indexer] === show.id[indexer]).length === 1;\n            if (showExists) {\n                state.shows[shows.indexOf(showExists)] = show;\n            } else {\n                state.shows.push(show);\n            }\n        }\n    },\n    // Add all blocking code here\n    // No actions should write to the store\n    // Please use context.commit to fire off a mutation that'll update the store\n    // Do not use store.commit in any actions!\n    actions: {\n        login(context, credentials) {\n            const { commit } = context;\n            commit(LOGIN_PENDING);\n\n            // @TODO: Add real JWT login\n            const apiLogin = () => Promise.resolve({ username: 'admin' });\n\n            apiLogin(credentials).then(user => {\n                return commit(LOGIN_SUCCESS, user);\n            }).catch(error => {\n                commit(LOGIN_FAILED, { error, credentials });\n            });\n        },\n        logout(context) {\n            const { commit } = context;\n            commit(LOGOUT);\n        },\n        getConfig(context, section) {\n            const { commit } = context;\n            return api.get('/config/' + (section || '')).then(res => {\n                if (section) {\n                    const config = res.data;\n                    return commit(ADD_CONFIG, { section, config });\n                }\n                Object.keys(res.data).forEach(section => {\n                    const config = res.data[section];\n                    commit(ADD_CONFIG, { section, config });\n                });\n            });\n        },\n        setConfig(context, { section, config }) {\n            if (section !== 'main') {\n                return;\n            }\n            return api.patch('config/' + section, config);\n        },\n        updateConfig(context, { section, config }) {\n            return store.commit(ADD_CONFIG, { section, config });\n        },\n        getShow(context, { indexer, id }) {\n            const { commit } = context;\n            return api.get('/series/' + indexer + id).then(res => {\n                commit(ADD_SHOW, res.data);\n            });\n        },\n        getShows(context, shows) {\n            const { commit, dispatch } = context;\n\n            // If no shows are provided get all of them\n            if (!shows) {\n                return api.get('/series?limit=1000').then(res => {\n                    const shows = res.data;\n                    return shows.forEach(show => {\n                        commit(ADD_SHOW, show);\n                    });\n                });\n            }\n\n            return shows.forEach(show => dispatch('getShow', show));\n        },\n        testNotifications() {\n            return displayNotification('error', 'test', 'test<br><i class=\"test-class\">hello <b>world</b></i><ul><li>item 1</li><li>item 2</li></ul>', 'notification-test');\n        },\n        setLayout(context, { page, layout }) {\n            return api.patch('config/main', {\n                layout: {\n                    [page]: layout\n                    // For now we reload the page since the layouts use python still\n                } }).then(setTimeout(() => location.reload(), 500));\n        }\n    },\n    // @TODO Add logging here\n    plugins: []\n});\n\nconst websocketUrl = (() => {\n    const proto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    const webRoot = apiRoot.replace('/api/v2/', '');\n    const WSMessageUrl = '/ui';\n    return proto + '//' + window.location.hostname + ':' + window.location.port + webRoot + '/ws' + WSMessageUrl;\n})();\n\nVue.use(VueNativeSock, websocketUrl, {\n    store,\n    format: 'json',\n    reconnection: true, // (Boolean) whether to reconnect automatically (false)\n    reconnectionAttempts: 2, // (Number) number of reconnection attempts before giving up (Infinity),\n    reconnectionDelay: 1000 // (Number) how long to initially wait before attempting a new (1000)\n});\n\nwindow.store = store;\n\n},{}]},{},[1]);\n"],"file":"store.js"}