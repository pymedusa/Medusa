{"version":3,"names":[],"mappings":"","sources":["js/store.js"],"sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n'use strict';\n\nvar _mutations;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* globals Vue, Vuex */\nvar VueNativeSock = window.VueNativeSock.default;\nvar _Vuex = Vuex,\n    Store = _Vuex.Store;\nvar _window = window,\n    displayNotification = _window.displayNotification;\n\n\nVue.use(Vuex);\n\n// These are used for mutation names\n// There are no naming conventions so try and match\n// similarly to what we already use when adding new ones.\nvar mutationTypes = {\n    LOGIN_PENDING: '🔒 Logging in',\n    LOGIN_SUCCESS: '🔒 ✅ Login Successful',\n    LOGIN_FAILED: '🔒 ❌ Login Failed',\n    LOGOUT: '🔒 Logout',\n    REFRESH_TOKEN: '🔒 Refresh Token',\n    REMOVE_AUTH_ERROR: '🔒 Remove Auth Error',\n    SOCKET_ONOPEN: 'SOCKET_ONOPEN',\n    SOCKET_ONCLOSE: 'SOCKET_ONCLOSE',\n    SOCKET_ONERROR: 'SOCKET_ONERROR',\n    SOCKET_ONMESSAGE: 'SOCKET_ONMESSAGE',\n    SOCKET_RECONNECT: 'SOCKET_RECONNECT',\n    SOCKET_RECONNECT_ERROR: 'SOCKET_RECONNECT_ERROR',\n    NOTIFICATIONS_ENABLED: '🔔 Notifications Enabled',\n    NOTIFICATIONS_DISABLED: '🔔 Notifications Disabled',\n    ADD_CONFIG: '⚙️ Config added to store',\n    ADD_SHOW: '📺 Show added to store'\n};\n\n// This will be moved up later on\n// once we move mutationTypes to a seperate file.\nvar LOGIN_PENDING = mutationTypes.LOGIN_PENDING,\n    LOGIN_SUCCESS = mutationTypes.LOGIN_SUCCESS,\n    LOGIN_FAILED = mutationTypes.LOGIN_FAILED,\n    LOGOUT = mutationTypes.LOGOUT,\n    REFRESH_TOKEN = mutationTypes.REFRESH_TOKEN,\n    REMOVE_AUTH_ERROR = mutationTypes.REMOVE_AUTH_ERROR,\n    SOCKET_ONOPEN = mutationTypes.SOCKET_ONOPEN,\n    SOCKET_ONCLOSE = mutationTypes.SOCKET_ONCLOSE,\n    SOCKET_ONERROR = mutationTypes.SOCKET_ONERROR,\n    SOCKET_ONMESSAGE = mutationTypes.SOCKET_ONMESSAGE,\n    SOCKET_RECONNECT = mutationTypes.SOCKET_RECONNECT,\n    SOCKET_RECONNECT_ERROR = mutationTypes.SOCKET_RECONNECT_ERROR,\n    NOTIFICATIONS_ENABLED = mutationTypes.NOTIFICATIONS_ENABLED,\n    NOTIFICATIONS_DISABLED = mutationTypes.NOTIFICATIONS_DISABLED,\n    ADD_CONFIG = mutationTypes.ADD_CONFIG,\n    ADD_SHOW = mutationTypes.ADD_SHOW;\n\n\nvar store = new Store({\n    state: {\n        auth: {\n            isAuthenticated: false,\n            user: {},\n            tokens: {\n                access: null,\n                refresh: null\n            },\n            error: null\n        },\n        // Websocket\n        socket: {\n            isConnected: false,\n            // Current message\n            message: {},\n            // Delivered messages for this session\n            messages: [],\n            reconnectError: false\n        },\n        notifications: {\n            enabled: true\n        },\n        qualities: {},\n        statuses: {},\n        // Main config\n        config: {\n            wikiUrl: null,\n            donationsUrl: null,\n            localUser: null,\n            posterSortdir: null,\n            locale: null,\n            themeName: null,\n            selectedRootIndex: null,\n            webRoot: null,\n            namingForceFolders: null,\n            cacheDir: null,\n            databaseVersion: {\n                major: null,\n                minor: null\n            },\n            programDir: null,\n            animeSplitHomeInTabs: null,\n            torrents: {\n                authType: null,\n                dir: null,\n                enabled: null,\n                highBandwidth: null,\n                host: null,\n                label: null,\n                labelAnime: null,\n                method: null,\n                path: null,\n                paused: null,\n                rpcurl: null,\n                seedLocation: null,\n                seedTime: null,\n                username: null,\n                verifySSL: null\n            },\n            layout: {\n                show: {\n                    specials: null,\n                    showListOrder: [],\n                    allSeasons: null\n                },\n                home: null,\n                history: null,\n                schedule: null\n            },\n            dbPath: null,\n            nzb: {\n                enabled: null,\n                method: null,\n                nzbget: {\n                    category: null,\n                    categoryAnime: null,\n                    categoryAnimeBacklog: null,\n                    categoryBacklog: null,\n                    host: null,\n                    priority: null,\n                    useHttps: null,\n                    username: null\n                },\n                sabnzbd: {\n                    category: null,\n                    forced: null,\n                    categoryAnime: null,\n                    categoryBacklog: null,\n                    categoryAnimeBacklog: null,\n                    host: null,\n                    username: null\n                }\n            },\n            configFile: null,\n            fanartBackground: null,\n            trimZero: null,\n            animeSplitHome: null,\n            branch: null,\n            commitHash: null,\n            indexers: {\n                config: {\n                    main: {\n                        externalMappings: {},\n                        statusMap: {},\n                        traktIndexers: {},\n                        validLanguages: [],\n                        langabbvToId: {}\n                    },\n                    indexers: {\n                        tvdb: {\n                            apiParams: {\n                                useZip: null,\n                                language: null\n                            },\n                            baseUrl: null,\n                            enabled: null,\n                            icon: null,\n                            id: null,\n                            identifier: null,\n                            mappedTo: null,\n                            name: null,\n                            scene_loc: null, // eslint-disable-line camelcase\n                            showUrl: null,\n                            xemOrigin: null\n                        },\n                        tmdb: {\n                            apiParams: {\n                                useZip: null,\n                                language: null\n                            },\n                            baseUrl: null,\n                            enabled: null,\n                            icon: null,\n                            id: null,\n                            identifier: null,\n                            mappedTo: null,\n                            name: null,\n                            scene_loc: null, // eslint-disable-line camelcase\n                            showUrl: null,\n                            xemOrigin: null\n                        },\n                        tvmaze: {\n                            apiParams: {\n                                useZip: null,\n                                language: null\n                            },\n                            baseUrl: null,\n                            enabled: null,\n                            icon: null,\n                            id: null,\n                            identifier: null,\n                            mappedTo: null,\n                            name: null,\n                            scene_loc: null, // eslint-disable-line camelcase\n                            showUrl: null,\n                            xemOrigin: null\n                        }\n                    }\n                }\n            },\n            sourceUrl: null,\n            rootDirs: [],\n            fanartBackgroundOpacity: null,\n            appArgs: [],\n            emby: {\n                enabled: null,\n                host: null\n            },\n            comingEpsDisplayPaused: null,\n            sortArticle: null,\n            timePreset: null,\n            plex: {\n                client: {\n                    host: [],\n                    username: null,\n                    enabled: null\n                },\n                server: {\n                    updateLibrary: null,\n                    host: [],\n                    enabled: null,\n                    notify: {\n                        download: null,\n                        subtitleDownload: null,\n                        snatch: null\n                    }\n                }\n            },\n            subtitles: {\n                enabled: null\n            },\n            fuzzyDating: null,\n            backlogOverview: {\n                status: null,\n                period: null\n            },\n            posterSortby: null,\n            kodi: {\n                enabled: null,\n                alwaysOn: null,\n                libraryCleanPending: null,\n                cleanLibrary: null,\n                host: [],\n                notify: {\n                    snatch: null,\n                    download: null,\n                    subtitleDownload: null\n                },\n                update: {\n                    library: null,\n                    full: null,\n                    onlyFirst: null\n                }\n            },\n            news: {\n                lastRead: null,\n                latest: null,\n                unread: null\n            },\n            logs: {\n                loggingLevels: {},\n                numErrors: null,\n                numWarnings: null\n            },\n            failedDownloads: {\n                enabled: null,\n                deleteFailed: null\n            },\n            postProcessing: {\n                processMethod: null,\n                postponeIfNoSubs: null\n            },\n            sslVersion: null,\n            pythonVersion: null,\n            comingEpsSort: null,\n            githubUrl: null,\n            datePreset: null,\n            subtitlesMulti: null,\n            pid: null,\n            os: null,\n            anonRedirect: null,\n            logDir: null,\n            recentShows: []\n        },\n        // Loaded show list\n        // New shows can be added via\n        // $store.dispatch('getShow', { indexer, id });\n        shows: [],\n        // We use this so we can fallback to a\n        // default object that resides in the shows array\n        defaults: {\n            show: {\n                id: {\n                    tvdb: null,\n                    slug: null\n                },\n                rating: {\n                    imdb: {\n                        rating: null,\n                        votes: null\n                    }\n                },\n                country_codes: [], // eslint-disable-line camelcase\n                network: null,\n                airs: null,\n                config: {\n                    qualities: null,\n                    defaultEpisodeStatus: null,\n                    dvdOrder: null,\n                    seasonFolders: null,\n                    scene: null,\n                    sports: null,\n                    paused: null,\n                    location: null,\n                    airByDate: null,\n                    release: null,\n                    aliases: null,\n                    subtitlesEnabled: null,\n                    anime: null\n                }\n            }\n        }\n    },\n    // The only place the state should be updated is here\n    // Please add new mutations in the same order as the mutatinType list\n    mutations: (_mutations = {}, _defineProperty(_mutations, LOGIN_PENDING, function () {}), _defineProperty(_mutations, LOGIN_SUCCESS, function (state, user) {\n        state.auth.user = user;\n        state.auth.isAuthenticated = true;\n        state.auth.error = null;\n    }), _defineProperty(_mutations, LOGIN_FAILED, function (state, _ref) {\n        var error = _ref.error;\n\n        state.auth.user = {};\n        state.auth.isAuthenticated = false;\n        state.auth.error = error;\n    }), _defineProperty(_mutations, LOGOUT, function (state) {\n        state.auth.user = {};\n        state.auth.isAuthenticated = false;\n        state.auth.error = null;\n    }), _defineProperty(_mutations, REFRESH_TOKEN, function () {}), _defineProperty(_mutations, REMOVE_AUTH_ERROR, function () {}), _defineProperty(_mutations, SOCKET_ONOPEN, function (state) {\n        state.socket.isConnected = true;\n    }), _defineProperty(_mutations, SOCKET_ONCLOSE, function (state) {\n        state.socket.isConnected = false;\n    }), _defineProperty(_mutations, SOCKET_ONERROR, function (state, event) {\n        console.error(state, event);\n    }), _defineProperty(_mutations, SOCKET_ONMESSAGE, function (state, message) {\n        var data = message.data,\n            event = message.event;\n\n        // Set the current message\n\n        state.socket.message = message;\n\n        if (event === 'notification') {\n            // Save it so we can look it up later\n            var existingMessage = state.socket.messages.filter(function (message) {\n                return message.hash === data.hash;\n            });\n            if (existingMessage.length === 1) {\n                state.socket.messages[state.socket.messages.indexOf(existingMessage)] = message;\n            } else {\n                state.socket.messages.push(message);\n            }\n        }\n    }), _defineProperty(_mutations, SOCKET_RECONNECT, function (state, count) {\n        console.info(state, count);\n    }), _defineProperty(_mutations, SOCKET_RECONNECT_ERROR, function (state) {\n        state.socket.reconnectError = true;\n\n        var title = 'Error connecting to websocket';\n        var error = '';\n        error += 'Please check your network connection. ';\n        error += 'If you are using a reverse proxy, please take a look at our wiki for config examples.';\n\n        displayNotification('notice', title, error);\n    }), _defineProperty(_mutations, NOTIFICATIONS_ENABLED, function (state) {\n        state.notifications.enabled = true;\n    }), _defineProperty(_mutations, NOTIFICATIONS_DISABLED, function (state) {\n        state.notifications.enabled = false;\n    }), _defineProperty(_mutations, ADD_CONFIG, function (state, _ref2) {\n        var section = _ref2.section,\n            config = _ref2.config;\n\n        if (section === 'main') {\n            state.config = config;\n        }\n        if (['qualities', 'statuses'].includes(section)) {\n            state[section] = config;\n        }\n    }), _defineProperty(_mutations, ADD_SHOW, function (state, show) {\n        var shows = state.shows;\n\n        var showExists = shows.filter(function (_ref3) {\n            var id = _ref3.id,\n                indexer = _ref3.indexer;\n            return id[indexer] === show.id[indexer];\n        }).length === 1;\n        if (showExists) {\n            state.shows[shows.indexOf(showExists)] = show;\n        } else {\n            state.shows.push(show);\n        }\n    }), _mutations),\n    // Add all blocking code here\n    // No actions should write to the store\n    // Please use context.commit to fire off a mutation that'll update the store\n    // Do not use store.commit in any actions!\n    actions: {\n        login: function login(context, credentials) {\n            var commit = context.commit;\n\n            commit(LOGIN_PENDING);\n\n            // @TODO: Add real JWT login\n            var apiLogin = function apiLogin() {\n                return Promise.resolve(credentials);\n            };\n\n            apiLogin(credentials).then(function (user) {\n                return commit(LOGIN_SUCCESS, user);\n            }).catch(function (error) {\n                commit(LOGIN_FAILED, { error: error, credentials: credentials });\n            });\n        },\n        logout: function logout(context) {\n            var commit = context.commit;\n\n            commit(LOGOUT);\n        },\n        getConfig: function getConfig(context, section) {\n            var commit = context.commit;\n\n            return api.get('/config/' + (section || '')).then(function (res) {\n                if (section) {\n                    var config = res.data;\n                    return commit(ADD_CONFIG, { section: section, config: config });\n                }\n                Object.keys(res.data).forEach(function (section) {\n                    var config = res.data[section];\n                    commit(ADD_CONFIG, { section: section, config: config });\n                });\n            });\n        },\n        setConfig: function setConfig(context, _ref4) {\n            var section = _ref4.section,\n                config = _ref4.config;\n\n            if (section !== 'main') {\n                return;\n            }\n            return api.patch('config/' + section, config);\n        },\n        updateConfig: function updateConfig(context, _ref5) {\n            var section = _ref5.section,\n                config = _ref5.config;\n\n            return store.commit(ADD_CONFIG, { section: section, config: config });\n        },\n        getShow: function getShow(context, _ref6) {\n            var indexer = _ref6.indexer,\n                id = _ref6.id;\n            var commit = context.commit;\n\n            return api.get('/series/' + indexer + id).then(function (res) {\n                commit(ADD_SHOW, res.data);\n            });\n        },\n        getShows: function getShows(context, shows) {\n            var commit = context.commit,\n                dispatch = context.dispatch;\n\n            // If no shows are provided get all of them\n\n            if (!shows) {\n                return api.get('/series?limit=1000').then(function (res) {\n                    var shows = res.data;\n                    return shows.forEach(function (show) {\n                        commit(ADD_SHOW, show);\n                    });\n                });\n            }\n\n            return shows.forEach(function (show) {\n                return dispatch('getShow', show);\n            });\n        },\n        testNotifications: function testNotifications() {\n            return displayNotification('error', 'test', 'test<br><i class=\"test-class\">hello <b>world</b></i><ul><li>item 1</li><li>item 2</li></ul>', 'notification-test');\n        },\n        setLayout: function setLayout(context, _ref7) {\n            var page = _ref7.page,\n                layout = _ref7.layout;\n\n            return api.patch('config/main', {\n                layout: _defineProperty({}, page, layout)\n                // For now we reload the page since the layouts use python still\n            }).then(setTimeout(function () {\n                return location.reload();\n            }, 500));\n        }\n    },\n    // @TODO Add logging here\n    plugins: []\n});\n\nvar websocketUrl = function () {\n    var proto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    var WSMessageUrl = '/ui';\n    return proto + '//' + window.location.hostname + ':' + window.location.port + webRoot + '/ws' + WSMessageUrl;\n}();\n\nVue.use(VueNativeSock, websocketUrl, {\n    store: store,\n    format: 'json',\n    reconnection: true, // (Boolean) whether to reconnect automatically (false)\n    reconnectionAttempts: 2, // (Number) number of reconnection attempts before giving up (Infinity),\n    reconnectionDelay: 1000 // (Number) how long to initially wait before attempting a new (1000)\n});\n\nwindow.store = store;\n\n},{}]},{},[1]);\n"],"file":"store.js"}