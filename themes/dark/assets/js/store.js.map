{"version":3,"names":[],"mappings":"","sources":["js/store.js"],"sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/* globals Vue */\nconst Puex = window.puex.default;\nconst VueNativeSock = window.VueNativeSock.default;\nconst displayNotification = window.displayNotification;\n\nVue.use(Puex);\n\n// These are used for mutation names\n// There are no naming conventions so try and match\n// similarly to what we already use when adding new ones.\nconst mutationTypes = {\n    LOGIN_PENDING: '🔒 Login Pending',\n    LOGIN_SUCCESS: '🔒 ✅ Login Successful',\n    LOGIN_FAILED: '🔒 ❌ Login Failed',\n    LOGOUT: '🔒 Logout',\n    REFRESH_TOKEN: '🔒 Refresh Token',\n    REMOVE_AUTH_ERROR: '🔒 Remove Auth Error',\n    SOCKET_ONOPEN: 'SOCKET_ONOPEN',\n    SOCKET_ONCLOSE: 'SOCKET_ONCLOSE',\n    SOCKET_ONERROR: 'SOCKET_ONERROR',\n    SOCKET_ONMESSAGE: 'SOCKET_ONMESSAGE',\n    SOCKET_RECONNECT: 'SOCKET_RECONNECT',\n    SOCKET_RECONNECT_ERROR: 'SOCKET_RECONNECT_ERROR',\n    NOTIFICATIONS_ENABLED: '🔔 Notifications Enabled',\n    NOTIFICATIONS_DISABLED: '🔔 Notifications Disabled',\n    ADD_CONFIG: '⚙️ Global config added to store',\n    ADD_SHOW: '📺 Show added to store'\n};\n\n// This will be moved up later on\n// once we move mutationTypes to a seperate file.\nconst {\n    LOGIN_PENDING,\n    LOGIN_SUCCESS,\n    LOGIN_FAILED,\n    LOGOUT,\n    REFRESH_TOKEN,\n    REMOVE_AUTH_ERROR,\n    SOCKET_ONOPEN,\n    SOCKET_ONCLOSE,\n    SOCKET_ONERROR,\n    SOCKET_ONMESSAGE,\n    SOCKET_RECONNECT,\n    SOCKET_RECONNECT_ERROR,\n    NOTIFICATIONS_ENABLED,\n    NOTIFICATIONS_DISABLED,\n    ADD_CONFIG,\n    ADD_SHOW\n} = mutationTypes;\n\nconst store = new Puex({\n    state: {\n        // Websocket\n        socket: {\n            isConnected: false,\n            // Current message\n            message: '',\n            // Delivered messages for this session\n            messages: [],\n            reconnectError: false\n        },\n        notifications: {\n            enabled: true\n        },\n        // Main config\n        config: {\n            wikiUrl: null,\n            localUser: null,\n            posterSortdir: null,\n            locale: null,\n            themeName: null,\n            selectedRootIndex: null,\n            webRoot: null,\n            namingForceFolders: null,\n            cacheDir: null,\n            databaseVersion: null,\n            programDir: null,\n            animeSplitHomeInTabs: null,\n            layout: {\n                show: {\n                    allSeasons: null\n                }\n            },\n            dbPath: null,\n            nzb: null,\n            configFile: null,\n            fanartBackground: null,\n            trimZero: null,\n            animeSplitHome: null,\n            branch: null,\n            commitHash: null,\n            indexers: null,\n            sourceUrl: null,\n            rootDirs: null,\n            fanartBackgroundOpacity: null,\n            appArgs: null,\n            emby: {},\n            logDir: null,\n            sortArticle: null,\n            timePreset: null,\n            plex: {},\n            subtitles: {\n                enabled: null\n            },\n            fuzzyDating: null,\n            backlogOverview: null,\n            posterSortby: null,\n            kodi: {},\n            sslVersion: null,\n            pythonVersion: null,\n            comingEpsSort: null,\n            githubUrl: null,\n            datePreset: null,\n            subtitlesMulti: null,\n            os: null,\n            anonRedirect: null,\n            torrents: null\n        },\n        // Loaded show list\n        // New shows can be added via\n        // $store.dispatch('getShow', { indexer, id });\n        shows: [],\n        // We use this so we can fallback to a\n        // default object that resides in the shows array\n        defaults: {\n            show: {\n                id: {\n                    tvdb: null,\n                    slug: null\n                },\n                rating: {\n                    imdb: {\n                        rating: null,\n                        votes: null\n                    }\n                },\n                country_codes: [], // eslint-disable-line camelcase\n                network: null,\n                airs: null,\n                config: {\n                    qualities: null,\n                    defaultEpisodeStatus: null,\n                    dvdOrder: null,\n                    seasonFolders: null,\n                    scene: null,\n                    sports: null,\n                    paused: null,\n                    location: null,\n                    airByDate: null,\n                    release: null,\n                    aliases: null,\n                    subtitlesEnabled: null,\n                    anime: null\n                }\n            }\n        }\n    },\n    // The only place the state should be updated is here\n    // Please add new mutations in the same order as the mutatinType list\n    mutations: {\n        [LOGIN_PENDING]() {},\n        [LOGIN_SUCCESS]() {},\n        [LOGIN_FAILED]() {},\n        [LOGOUT]() {},\n        [REFRESH_TOKEN]() {},\n        [REMOVE_AUTH_ERROR]() {},\n        [SOCKET_ONOPEN](state) {\n            state.socket.isConnected = true;\n        },\n        [SOCKET_ONCLOSE](state) {\n            state.socket.isConnected = false;\n        },\n        [SOCKET_ONERROR](state, event) {\n            console.error(state, event);\n        },\n        // Default handler called for all websocket methods\n        [SOCKET_ONMESSAGE](state, message) {\n            const { data, event } = message;\n            const { body, hash, type, title } = data;\n\n            // Set the current message\n            state.socket.message = message;\n\n            // Show the notification to the user\n            if (event === 'notification') {\n                displayNotification(type, title, body, hash);\n            } else {\n                displayNotification('info', '', message);\n            }\n\n            // Save it so we can look it up later\n            const existingMessage = state.socket.messages.filter(message => message.hash === hash);\n            if (existingMessage.length === 1) {\n                state.socket.messages[state.socket.messages.indexOf(existingMessage)] = message;\n            } else {\n                state.socket.messages.push(message);\n            }\n        },\n        // Mutations for websocket reconnect methods\n        [SOCKET_RECONNECT](state, count) {\n            console.info(state, count);\n        },\n        [SOCKET_RECONNECT_ERROR](state) {\n            state.socket.reconnectError = true;\n\n            const title = 'Error connecting to websocket';\n            let error = '';\n            error += 'Please check your network connection. ';\n            error += 'If you are using a reverse proxy, please take a look at our wiki for config examples.';\n\n            displayNotification('notice', title, error);\n        },\n        [NOTIFICATIONS_ENABLED](state) {\n            state.notifications.enabled = true;\n        },\n        [NOTIFICATIONS_DISABLED](state) {\n            state.notifications.enabled = false;\n        },\n        [ADD_CONFIG](state, config) {\n            state.config = config;\n        },\n        [ADD_SHOW](state, show) {\n            const { shows } = state;\n            const showExists = shows.filter(({ id, indexer }) => id[indexer] === show.id[indexer]).length === 1;\n            if (showExists) {\n                state.shows[shows.indexOf(showExists)] = show;\n            } else {\n                state.shows.push(show);\n            }\n        }\n    },\n    // Add all blocking code here\n    // No actions should write to the store\n    // Please use store.commit to fire off a mutation that'll update the store\n    actions: {\n        getConfig() {\n            return api.get('/config/main').then(res => {\n                store.commit(ADD_CONFIG, res.data);\n            });\n        },\n        getShow(context, { indexer, id }) {\n            return api.get('/series/' + indexer + id).then(res => {\n                store.commit(ADD_SHOW, res.data);\n            });\n        },\n        getShows(context, shows) {\n            const { dispatch } = store;\n\n            // If no shows are provided get all of them\n            if (!shows) {\n                return api.get('/series?limit=1000').then(res => {\n                    const shows = res.data;\n                    return shows.forEach(show => {\n                        store.commit(ADD_SHOW, show);\n                    });\n                });\n            }\n\n            return shows.forEach(show => dispatch('getShow', show));\n        },\n        testNotifications() {\n            return displayNotification('error', 'test', 'test<br><i class=\"test-class\">hello <b>world</b></i><ul><li>item 1</li><li>item 2</li></ul>', 'notification-test--');\n        },\n        setLayout(context, { page, layout }) {\n            return api.patch('config/main', {\n                layout: {\n                    [page]: layout\n                    // }).then(setTimeout(() => dispatch('getConfig'), 500));\n                    // For now we reload the page since the layouts use python still\n                } }).then(location.reload());\n        }\n    },\n    // @TODO Add logging here\n    plugins: []\n});\n\nconst websocketUrl = (() => {\n    const proto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n    const webRoot = apiRoot.replace('/api/v2/', '');\n    const WSMessageUrl = '/ui';\n    return proto + '//' + window.location.hostname + ':' + window.location.port + webRoot + '/ws' + WSMessageUrl;\n})();\n\nVue.use(VueNativeSock, websocketUrl, {\n    store,\n    format: 'json',\n    reconnection: true, // (Boolean) whether to reconnect automatically (false)\n    reconnectionAttempts: 2, // (Number) number of reconnection attempts before giving up (Infinity),\n    reconnectionDelay: 1000 // (Number) how long to initially wait before attempting a new (1000)\n});\n\nwindow.store = store;\n\n},{}]},{},[1]);\n"],"file":"store.js"}