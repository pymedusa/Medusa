{"version":3,"names":[],"mappings":"","sources":["js/ajax-episode-search.js"],"sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\nconst searchStatusUrl = 'home/getManualSearchStatus';\nlet failedDownload = false;\nlet qualityDownload = false;\nlet selectedEpisode = '';\nPNotify.prototype.options.maxonscreen = 5;\n\n$.fn.forcedSearches = [];\n\nfunction enableLink(el) {\n    el.on('click.disabled', false);\n    el.prop('enableClick', '1');\n    el.fadeTo('fast', 1);\n}\n\nfunction disableLink(el) {\n    el.off('click.disabled');\n    el.prop('enableClick', '0');\n    el.fadeTo('fast', 0.5);\n}\n\nfunction updateImages(data) {\n    $.each(data.episodes, (name, ep) => {\n        // Get td element for current ep\n        const loadingImage = 'loading16.gif';\n        const queuedImage = 'queued.png';\n        const searchImage = 'search16.png';\n        let htmlContent = '';\n        // Try to get the <a> Element\n        const el = $('a[id=' + ep.indexer_id + 'x' + ep.series_id + 'x' + ep.season + 'x' + ep.episode + ']');\n        const img = el.children('img[data-ep-search]');\n        const parent = el.parent();\n        if (el) {\n            if (ep.searchstatus.toLowerCase() === 'searching') {\n                // El=$('td#' + ep.season + 'x' + ep.episode + '.search img');\n                img.prop('title', 'Searching');\n                img.prop('alt', 'Searching');\n                img.prop('src', 'images/' + loadingImage);\n                disableLink(el);\n                htmlContent = ep.searchstatus;\n            } else if (ep.searchstatus.toLowerCase() === 'queued') {\n                // El=$('td#' + ep.season + 'x' + ep.episode + '.search img');\n                img.prop('title', 'Queued');\n                img.prop('alt', 'queued');\n                img.prop('src', 'images/' + queuedImage);\n                disableLink(el);\n                htmlContent = ep.searchstatus;\n            } else if (ep.searchstatus.toLowerCase() === 'finished') {\n                // El=$('td#' + ep.season + 'x' + ep.episode + '.search img');\n                img.prop('title', 'Searching');\n                img.prop('alt', 'searching');\n                img.parent().prop('class', 'epRetry');\n                img.prop('src', 'images/' + searchImage);\n                enableLink(el);\n\n                // Update Status and Quality\n                let qualityPill = '';\n                if (ep.quality_style !== 'na') {\n                    qualityPill = ' <span class=\"quality ' + ep.quality_style + '\">' + ep.quality_name + '</span>';\n                }\n                htmlContent = ep.status + qualityPill;\n                parent.closest('tr').prop('class', ep.overview + ' season-' + ep.season + ' seasonstyle');\n            }\n            // Update the status column if it exists\n            parent.siblings('.col-status').html(htmlContent);\n        }\n        const elementCompleteEpisodes = $('a[id=forceUpdate-' + ep.indexer_id + 'x' + ep.series_id + 'x' + ep.season + 'x' + ep.episode + ']');\n        const imageCompleteEpisodes = elementCompleteEpisodes.children('img');\n        if (elementCompleteEpisodes) {\n            if (ep.searchstatus.toLowerCase() === 'searching') {\n                imageCompleteEpisodes.prop('title', 'Searching');\n                imageCompleteEpisodes.prop('alt', 'Searching');\n                imageCompleteEpisodes.prop('src', 'images/' + loadingImage);\n                disableLink(elementCompleteEpisodes);\n            } else if (ep.searchstatus.toLowerCase() === 'queued') {\n                imageCompleteEpisodes.prop('title', 'Queued');\n                imageCompleteEpisodes.prop('alt', 'queued');\n                imageCompleteEpisodes.prop('src', 'images/' + queuedImage);\n            } else if (ep.searchstatus.toLowerCase() === 'finished') {\n                imageCompleteEpisodes.prop('title', 'Forced Search');\n                imageCompleteEpisodes.prop('alt', '[search]');\n                imageCompleteEpisodes.prop('src', 'images/' + searchImage);\n                if (ep.overview.toLowerCase() === 'snatched') {\n                    elementCompleteEpisodes.closest('tr').remove();\n                } else {\n                    enableLink(elementCompleteEpisodes);\n                }\n            }\n        }\n    });\n}\n\nfunction checkManualSearches() {\n    let pollInterval = 5000;\n\n    // Try to get a indexer name and series id. If we can't get any, we request the manual search status for all shows.\n    const indexerName = $('#indexer-name').val();\n    const seriesId = $('#series-id').val();\n\n    const url = seriesId === undefined ? searchStatusUrl : searchStatusUrl + '?indexername=' + indexerName + '&seriesid=' + seriesId;\n    $.ajax({\n        url,\n        error() {\n            pollInterval = 30000;\n        },\n        type: 'GET',\n        dataType: 'JSON',\n        complete() {\n            setTimeout(checkManualSearches, pollInterval);\n        },\n        timeout: 15000 // Timeout every 15 secs\n    }).done(data => {\n        if (data.episodes) {\n            pollInterval = 5000;\n        } else {\n            pollInterval = 15000;\n        }\n        updateImages(data);\n        // CleanupManualSearches(data);\n    });\n}\n\n$(document).ready(() => {\n    checkManualSearches();\n});\n\n$.ajaxEpSearch = function (options) {\n    options = $.extend({}, {\n        size: 16,\n        colorRow: false,\n        loadingImage: 'loading16.gif',\n        queuedImage: 'queued.png',\n        noImage: 'no16.png',\n        yesImage: 'yes16.png'\n    }, options);\n\n    $('.epRetry').on('click', function (event) {\n        event.preventDefault();\n\n        // Check if we have disabled the click\n        if ($(this).prop('enableClick') === '0') {\n            return false;\n        }\n\n        selectedEpisode = $(this);\n\n        $('#forcedSearchModalFailed').modal('show');\n    });\n\n    function forcedSearch() {\n        let imageName;\n        let imageResult;\n\n        const parent = selectedEpisode.parent();\n\n        // Create var for anchor\n        const link = selectedEpisode;\n\n        // Create var for img under anchor and set options for the loading gif\n        const img = selectedEpisode.children('img');\n        img.prop('title', 'loading');\n        img.prop('alt', '');\n        img.prop('src', 'images/' + options.loadingImage);\n\n        let url = selectedEpisode.prop('href');\n\n        if (!failedDownload) {\n            url = url.replace('retryEpisode', 'searchEpisode');\n        }\n\n        // Only pass the down_cur_quality flag when retryEpisode() is called\n        if (qualityDownload && url.indexOf('retryEpisode') >= 0) {\n            url += '&down_cur_quality=1';\n        }\n\n        // @TODO: Move to the API\n        $.getJSON(url, data => {\n            // If they failed then just put the red X\n            if (data.result.toLowerCase() === 'failure') {\n                imageName = options.noImage;\n                imageResult = 'failed';\n            } else {\n                // If the snatch was successful then apply the\n                // corresponding class and fill in the row appropriately\n                imageName = options.loadingImage;\n                imageResult = 'success';\n                // Color the row\n                if (options.colorRow) {\n                    parent.parent().removeClass('skipped wanted qual good unaired').addClass('snatched');\n                }\n                // Only if the queuing was successful, disable the onClick event of the loading image\n                disableLink(link);\n            }\n\n            // Put the corresponding image as the result of queuing of the manual search\n            img.prop('title', imageResult);\n            img.prop('alt', imageResult);\n            img.prop('height', options.size);\n            img.prop('src', 'images/' + imageName);\n        });\n\n        // Don't follow the link\n        return false;\n    }\n\n    $('.epSearch').on('click', function (event) {\n        event.preventDefault();\n\n        // Check if we have disabled the click\n        if ($(this).prop('enableClick') === '0') {\n            return false;\n        }\n\n        selectedEpisode = $(this);\n\n        // @TODO: Replace this with an easier to read selector\n        if ($(this).parent().parent().children('.col-status').children('.quality').length > 0) {\n            $('#forcedSearchModalQuality').modal('show');\n        } else {\n            forcedSearch();\n        }\n    });\n\n    $('.epManualSearch').on('click', function (event) {\n        event.preventDefault();\n\n        // @TODO: Omg this disables all the manual snatch icons, when one is clicked\n        if ($(this).hasClass('disabled')) {\n            return false;\n        }\n\n        $('.epManualSearch').addClass('disabled');\n        $('.epManualSearch').fadeTo(1, 0.1);\n\n        const url = this.href;\n        if (event.shiftKey || event.ctrlKey || event.which === 2) {\n            window.open(url, '_blank');\n        } else {\n            window.location = url;\n        }\n    });\n\n    $('#forcedSearchModalFailed .btn-medusa').on('click', function () {\n        failedDownload = $(this).text().toLowerCase() === 'yes';\n        $('#forcedSearchModalQuality').modal('show');\n    });\n\n    $('#forcedSearchModalQuality .btn-medusa').on('click', function () {\n        qualityDownload = $(this).text().toLowerCase() === 'yes';\n        forcedSearch();\n    });\n};\n\n},{}]},{},[1]);\n"],"file":"ajax-episode-search.js"}